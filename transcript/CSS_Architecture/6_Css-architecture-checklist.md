Transcript
This section will focus on the architecture of a design system, a design system should have a scalable

unmaintainable code base, and that starts with how we write.

Our stories have put together a checklist of best practices and guidelines that we need to follow to

have a scalable, unmaintainable system.

First, we need to be organized.

We need to have a fixed cost structure, a fixed guideline to follow and a consistent could be we need

to solve all those specificity issues.

For example, the CSFs from one component shouldn't conflicts with the success from another component.

We need to make sure that our code base correctly reflects the atomic design principles, even if it's

just the way we nimmi for us that we if we are on board in a new developer and we tell them we follow

the atomic design system guidelines, then it should be really easy for them to catch up.

We need to also make sure that the code we write, especially in this case, should be easy to understand.

And we can do this by making sure that we have appropriate comments, verbose and explanations of the

decisions we made in the first place.

Next, we need to make sure that the success is fully customizable and female.

That way, if our design team introduces a new color scheme or a new typography funds based on a specific

product in our company or something related to that, then access should automatically adapt to these

changes for that project.

Finally, we are going to make sure that the rate is reusable across teams and projects.

We should most likely have access as an external MTM package that we are pulling for any projects or

any team at any given time.

In the next lesson, we are going to get started setting up the foundations of our design system in

actual code.
